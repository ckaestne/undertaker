/*
 *   rsf2cnf - converts rsf files to dimacs cnf files
 *
 * Copyright (C) 2012 Ralf Hackner <rh@ralf-hackner.de>
 * Copyright (C) 2012-2013 Reinhard Tartler <tartler@informatik.uni-erlangen.de>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <stdlib.h>
#include <algorithm>
#include <cstdlib>
#include <unistd.h>
#include <fstream>
#include <boost/regex.hpp>

#include "PicosatCNF.h"
#include "CNFBuilder.h"
#include "IOException.h"
#include "RsfReader.h"
#include "KconfigWhitelist.h"
#include "Logging.h"
#include "bool.h"
#include "Kconfig.h"

using namespace kconfig;

static void usage(void){
    std::cerr << "rsf2cnf [-v] [-q] -m <model> [-W <file>] [-B <file>] [-r <rsf>] [-c <cnf>]" << std::endl;
    std::cerr << "  -v           increase verbosity" << std::endl;
    std::cerr << "  -q           decrease verbosity" << std::endl;
    std::cerr << "  -m <model>   file with inferences from golem, or a version 1.0 model file generated by rsf2model" << std::endl;
    std::cerr << "  -r <rsf>     (optional) original *.rsf file generated by dumpconf" << std::endl;
    std::cerr << "  -c <cnf>     (optional) merges constraints from given .cnf file" << std::endl;
    std::cerr << "  -W <file>    (optional) file with a whitelist of options that are always enabled" << std::endl;
    std::cerr << "  -B <file>    (optional) file with a blacklist of options that are always disabled" << std::endl;
    exit(1);
}

static void addTypeInfo(kconfig::CNF &cnf, ItemRsfReader *rsf){
    ItemRsfReader::iterator it;

    // add all CONFIG_* items
    for (it = rsf->begin(); it != rsf->end(); it++){
        std::string symbolname = it->first;
        std::string nameOfType = it->second[0];

        if (nameOfType == "boolean"){
            cnf.setSymbolType(symbolname, K_S_BOOLEAN);
        }
        else if (nameOfType == "tristate"){
            cnf.setSymbolType(symbolname, K_S_TRISTATE);
        }
        else if (nameOfType == "integer"){
            cnf.setSymbolType(symbolname, K_S_INT);
        }
        else if (nameOfType == "hex"){
            cnf.setSymbolType(symbolname, K_S_HEX);
        }
        else if (nameOfType == "string"){
            cnf.setSymbolType(symbolname, K_S_STRING);
        }
        else {
            cnf.setSymbolType(symbolname, K_S_OTHER);
        }
    }
}

static void addClauses(kconfig::CNFBuilder &builder, RsfReader *model){
    boost::regex isconfig = boost::regex("^(CONFIG|FILE)_[^ ]+$", boost::regex::perl);
    RsfReader::iterator it;

    // add all CONFIG_* items
    for (it = model->begin(); it != model->end(); it++){
        if(boost::regex_match(it->first, isconfig)){
            std::string clause = it->first;
            builder.addVar(clause);

            if (! it->second.empty()){
                // CONFIG_FOO depends on EXPR
                clause += " -> (" + it->second[0] +")";
                BoolExp *exp = BoolExp::parseString(clause);
                if (exp) {
                    builder.pushClause(exp);
                    delete exp;
                } else {
                    logger << error
                           << "failed to parse '" << clause << "'" << std::endl;
                }
            } else {
                // CONFIG_FOO depnends on Y
                // can be ignored
                clause += " -> 1";
            }

        }
    }
}

static void addAllwaysOnOff(kconfig::CNFBuilder &builder, RsfReader *model){
    const std::string magic_on("ALWAYS_ON");
    const std::string magic_off("ALWAYS_OFF");

    KconfigWhitelist *whitelist = KconfigWhitelist::getWhitelist();
    for(KconfigWhitelist::const_iterator iterator = (*whitelist).begin();
        iterator != (*whitelist).end(); ++iterator) {
        model->addMetaValue(magic_on, *iterator);
    }

    KconfigWhitelist *blacklist = KconfigWhitelist::getBlacklist();
    for(KconfigWhitelist::const_iterator iterator = (*blacklist).begin();
        iterator != (*blacklist).end(); ++iterator) {
        model->addMetaValue(magic_off, *iterator);
    }

    const StringList *aon = model->getMetaValue(magic_on);

    if (aon) {
        for (StringList::const_iterator cit = aon->begin();
             cit != aon->end(); cit++){
            std::string clause = *cit;
            BoolExp *exp = BoolExp::parseString(clause);
            builder.pushClause(exp);
            delete exp;
            builder.cnf->addMetaValue("ALWAYS_ON", *cit);
        }
    }

    aon = model->getMetaValue(magic_off);
    if (aon) {
        for (StringList::const_iterator cit = aon->begin();
             cit != aon->end(); cit++){
            std::string clause = "! " + *cit;
            BoolExp *exp = BoolExp::parseString(clause);
            builder.pushClause(exp);
            delete exp;
            builder.cnf->addMetaValue("ALWAYS_OFF", *cit);
        }
    }
}

int main(int argc, char **argv) {
    int opt;
    char *model_file = NULL;
    char *rsf_file = NULL;
    char *cnf_file = NULL;

    int loglevel = logger.getLogLevel();

    while ((opt = getopt(argc, argv, "m:r:c:W:B:vh")) != -1) {
        switch (opt) {
            int n;
            KconfigWhitelist *wl;
        case 'm':
            model_file = strdup(optarg);
            break;
        case 'r':
            rsf_file = strdup(optarg);
            break;
        case 'c':
            cnf_file = strdup(optarg);
            break;
        case 'q':
            loglevel = loglevel + 10;
            logger.setLogLevel(loglevel);
            break;
        case 'v':
            loglevel = loglevel - 10;
            if (loglevel < 0)
                loglevel = Logging::LOG_EVERYTHING;
            logger.setLogLevel(loglevel);
            break;
        case 'W':
            wl = KconfigWhitelist::getWhitelist();
            n = wl->loadWhitelist(optarg);
            if (n >= 0) {
                logger << info << "loaded " << n << " items to whitelist" << std::endl;
            } else {
                logger << error << "couldn't load whitelist" << std::endl;
                exit(-1);
            }
            break;
        case 'B':
            wl = KconfigWhitelist::getBlacklist();
            n = wl->loadWhitelist(optarg);
            if (n >= 0) {
                logger << info << "loaded " << n << " items to blacklist" << std::endl;
            } else {
                logger << error << "couldn't load blacklist" << std::endl;
                exit(-1);
            }
            break;
        case 'h':
            usage();
        default:
            break;
        }
    }

    if (!model_file)
        usage();

    PicosatCNF cnf;

    if (cnf_file) {
        std::fstream cnf_in_stream(cnf_file, std::fstream::in);
        if (!cnf_in_stream.good()) {
            logger << error << "could not open cnffile \"" << cnf_file << "\"" << std::endl;
            return 1;
        }
        cnf.readFromFile(cnf_in_stream);
    }

    kconfig::CNFBuilder builder;
    RsfReader *model = NULL;
    ItemRsfReader *rsf = NULL;
    builder.cnf = &cnf;

    std::fstream model_stream (model_file, std::fstream::in);
    if (!model_stream.good()) {
        logger << error << "could not open modelfile \"" << model_file << "\"" << std::endl;
        return 1;
    }

    model = new RsfReader(model_stream, "UNDERTAKER_SET");

    if (rsf_file) {
        std::fstream rsf_stream (rsf_file, std::fstream::in);
        if (!rsf_stream.good()) {
            logger << error << "could not open rsffile \"" << argv[2] << "\"" << std::endl;
            return 1;
        }
        rsf = new ItemRsfReader(rsf_stream);
    }

    addClauses(builder, model);
    addAllwaysOnOff(builder, model);
    if (rsf)
        addTypeInfo(cnf, rsf);

    std::string magic_inc("CONFIGURATION_SPACE_INCOMPLETE");

    if (model->getMetaValue(magic_inc)) {
        cnf.addMetaValue("CONFIGURATION_SPACE_INCOMPLETE", "True");
    }

    try {
        cnf.toFile(std::cout);
    } catch (IOException e) {
        logger << error << e.what() << std::endl;
        return 1;
    }

    delete model;
    delete rsf;
}
