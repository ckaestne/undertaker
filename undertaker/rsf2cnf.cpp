/*
 *   rsf2cnf - converts rsf files to dimacs cnf files
 *
 * Copyright (C) 2012 Ralf Hackner <rh@ralf-hackner.de>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <stdlib.h>
#include <algorithm>
#include <cstdlib>
#include <fstream>
#include <boost/regex.hpp>

#include "PicosatCNF.h"
#include "CNFBuilder.h"
#include "IOException.h"
#include "RsfReader.h"
#include "Logging.h"
#include "bool.h"

using namespace kconfig;

enum symbol_type {
    S_UNKNOWN, S_BOOLEAN, S_TRISTATE, S_INT, S_HEX, S_STRING, S_OTHER
};

static void usage(void){
    std::cerr << "rsf2cnf <model> <rsf> <cnf>" << std::endl;
    std::cerr << "    <model>   *.model file generated by rsf2model" << std::endl;
    std::cerr << "    <rsf>     original *.rsf file generated by dumpconf" << std::endl;
    std::cerr << "    <cnf>     (optional) joins this .cnf file to the model" << std::endl;
    exit(1);
}

static void addTypeInfo(CNF &cnf, ItemRsfReader *rsf){
    ItemRsfReader::iterator it;

    // add all CONFIG_* items
    for (it = rsf->begin(); it != rsf->end(); it++){
        std::string symbolname = it->first;
        std::string nameOfType = it->second[0];

        if (nameOfType == "boolean"){
            cnf.setSymbolType(symbolname, (int) S_BOOLEAN);
        }
        else if (nameOfType == "tristate"){
            cnf.setSymbolType(symbolname, (int) S_TRISTATE);
        }
        else if (nameOfType == "integer"){
            cnf.setSymbolType(symbolname, (int) S_INT);
        }
        else if (nameOfType == "hex"){
            cnf.setSymbolType(symbolname, (int) S_HEX);
        }
        else if (nameOfType == "string"){
            cnf.setSymbolType(symbolname, (int) S_STRING);
        }
        else {
            cnf.setSymbolType(symbolname, (int) S_OTHER);
        }
    }
}

static void addClauses(CNFBuilder &builder, RsfReader *model){
    boost::regex isconfig = boost::regex("^(CONFIG|FILE)_[^ ]+$", boost::regex::perl);
    RsfReader::iterator it;

    // add all CONFIG_* items
    for (it = model->begin(); it != model->end(); it++){
        if(boost::regex_match(it->first, isconfig)){
            std::string clause = it->first;
            builder.addVar(clause);

            if (! it->second.empty()){
                // CONFIG_FOO depends on EXPR
                clause += " -> (" + it->second[0] +")";
                BoolExp *exp = BoolExp::parseString(clause);
                if (exp) {
                    builder.pushClause(exp);
                    delete exp;
                } else {
                    logger << error
                           << "failed to parse '" << clause << "'" << std::endl;
                }
            } else {
                // CONFIG_FOO depnends on Y
                // can be ignored
                clause += " -> 1";
            }

        }
    }
}

static void addAllwaysOnOff(CNFBuilder &builder, RsfReader *model){
    std::string magic_on("ALWAYS_ON");
    std::string magic_off("ALWAYS_OFF");
    StringList::const_iterator it1;

    const StringList *aon = model->getMetaValue(magic_on);

    if (aon) {
        for (it1 = aon->begin(); it1 != aon->end(); it1++){
            std::string clause = *it1;
            BoolExp *exp = BoolExp::parseString(clause);
            builder.pushClause(exp);
            delete exp;
            builder.cnf->addMetaValue("ALWAYS_ON", clause);
        }
    }

    aon = model->getMetaValue(magic_off);
    if (aon) {
        for (it1 = aon->begin(); it1 != aon->end(); it1++){
            std::string clause = "! " + *it1;
            BoolExp *exp = BoolExp::parseString(clause);
            builder.pushClause(exp);
            delete exp;
            builder.cnf->addMetaValue("ALWAYS_OFF", clause);
        }
    }
}

int main(int argc, char **argv) {

    if (argc != 3 && argc != 4) {
        usage();
    }

    int loglevel;

    if (getenv("DEBUG")) {
        loglevel = Logging::LOG_EVERYTHING;
        logger.setLogLevel(loglevel);
    }

    PicosatCNF cnf;

    if (argc == 4) {
        std::fstream cnf_in_stream(argv[3], fstream::in);
        if (!cnf_in_stream.good()) {
            logger << error << "could not open cnffile \"" << argv[4] << "\"" << std::endl;
            return 1;
        }
        cnf.readFromFile(cnf_in_stream);
    }
    CNFBuilder builder;
    builder.cnf = &cnf;

    std::fstream model_stream (argv[1], fstream::in);
    if (!model_stream.good()) {
        logger << error << "could not open modelfile \"" << argv[1] << "\"" << std::endl;
        return 1;
    }

    std::fstream rsf_stream (argv[2], fstream::in);
    if (!rsf_stream.good()) {
        logger << error << "could not open rsffile \"" << argv[2] << "\"" << std::endl;
        return 1;
    }

    RsfReader *model = new RsfReader(model_stream, "UNDERTAKER_SET");
    ItemRsfReader *rsf = new ItemRsfReader(rsf_stream);

    addClauses(builder, model);
    addAllwaysOnOff(builder, model);
    addTypeInfo(cnf, rsf);

    std::string magic_inc("CONFIGURATION_SPACE_INCOMPLETE");

    if (model->getMetaValue(magic_inc)) {
        cnf.addMetaValue("CONFIGURATION_SPACE_INCOMPLETE", "True");
    }

    try {
        cnf.toFile(std::cout);
    } catch (IOException e) {
        logger << error << e.what() << std::endl;
        return 1;
    }
}

